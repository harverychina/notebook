# 面向对象编程

## 一、行为的定义和实现

* 初始化结构
```go
type Employee struct {
	Id   string
	Name string
	Age  int
}
```

* 格式化输出（实例和指针两种类型）
```go
// 格式化输出
func (e Employee) String() string {
	fmt.Printf("Address is %x\n", unsafe.Pointer(&e.Name))
	return fmt.Sprintf("ID:%s-Name:%s-Age:%d", e.Id, e.Name, e.Age)
}

// 格式化输出（指针方式）建议采用这种方法，内容没有被复制或改变
func (e *Employee) String() string {
	// 指针和实例的区别
	fmt.Printf("Address is %x", unsafe.Pointer(&e.Name))
	return fmt.Sprintf("ID:%s/Name:%s/Age:%d", e.Id, e.Name, e.Age)
}
```

* 三、测试实例
```go
func TestCreateEmployeeObj(t *testing.T) {
	e := Employee{"0", "Bob", 20}
	e1 := Employee{Name: "Mike", Age: 30}
	e2 := new(Employee) // 返回指针
	e2.Id = "2"
	e2.Age = 22
	e2.Name = "Rose"
	t.Log(e)
	t.Log(e1)
	t.Log(e1.Id)
	t.Log(e2)
	t.Logf("e is %T", e)
	// 返回employee的指针类型
	t.Logf("e2 is %T", e2)
}
```

* 四、测试格式输出
```go
// 调用格式化输出函数
func TestStructOperations(t *testing.T) {
	e := Employee{"0", "Bob", 20}
	// 指针和实例的区别
	fmt.Printf("Address is %x\n", unsafe.Pointer(&e.Name))
	//e := &Employee{"0", "Bob", 20}
	t.Log(e.String())
}
```

## 二、GO语言的相关接口

* 1、Go语言的接口与其他语言的不同
```
与其他主要的编程语言的差异
1）接口为非入侵性，实现不依赖于接口定义
2）所以接口的定义可以包含在接口使用者包内
```
* 2、接口变量
```go
var prog Coder = &GoProgrammer{}
// 类型
type GoProgrammer struct{}
// 实例
&GoProgrammer{}
```
* 3、自定义类型(接口的调用是不依赖接口定义)
```go
type IntConv func(op int) int

func timeSpent(inner IntConv) IntConv {
	return func(n int) int {
		start := time.Now()
		ret := inner(n)
		fmt.Println("time spent:", time.Since(start).Seconds())
		return ret
	}
}

func slowFun(op int) int {
	time.Sleep(time.Second * 1)
	return op
}

func TestFn(t *testing.T) {
	tsSF := timeSpent(slowFun)
	t.Log(tsSF(10))
}
```

## 三、扩展与复用

## 四、不一样的接口类型，一样的多态