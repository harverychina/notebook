# 并发编程

一、协程机制
1、协程与线程的区别

    * 创建时默认的stack的大小
        - JDK5以后Java Thread stack 默认为1M
        - Groutine的stack初始化大小为2K
    * 和KSE（Kernel Space Entity)的对应关系
        - Java Thread 是1:1
        - Groutine是M:N

2、协程示例
```go
func TestGroutine(t *testing.T) {
	for i := 0; i < 10; i++ {
		go func(i int) {
			// 值参会被复制，不会产生相互竞争
			fmt.Println(i)
		}(i)
	}
	time.Sleep(time.Millisecond * 50)
}
```
二、共享内存并发机制
1、锁(Java样例)
```Java
Lock lock = ...;
lock.lock();
try {
    // process(thread-safe)
} catch(Exception ex) {

} finally {
    lock.unlock();
}
```
* go 当中是使用 package sync中的 Mutex 和 RWlock来实现
```go
// 非线程操作
func TestCounter(t *testing.T) {
	counter := 0
	for i := 0; i < 5000; i++ {
		go func() {
			counter++
		}()
	}
	time.Sleep(1 * time.Second)
	t.Logf("counter = %d", counter)
}
// 线程保护模式
func TestCounterThreadSafe(t *testing.T) {
	var mut sync.Mutex
	counter := 0
	for i := 0; i < 5000; i++ {
		go func() {
			defer func() {
				mut.Unlock()
			}()
			mut.Lock()
			counter++
		}()
	}
	time.Sleep(1 * time.Second)
	t.Logf("counter = %d", counter)
}
// 线程并发等待机制
func TestCounterWaitGroup(t *testing.T) {
	var mut sync.Mutex
	var wg sync.WaitGroup
	counter := 0
	for i := 0; i < 5000; i++ {
		wg.Add(1)
		go func() {
			defer func() {
				mut.Unlock()
			}()
			mut.Lock()
			counter++
			wg.Done()
		}()
	}
	wg.Wait()
	t.Logf("counter = %d", counter)
}
```

三、CSP并发机制


四、多路选择和超时


五、channel的关闭和广播


六、任务的取消


七、Context与任务取消

